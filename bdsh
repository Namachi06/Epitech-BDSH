#!/bin/bash
# Shell Script Project


echoerr() {
    >&2 echo "$@";
}

my_echo_infile() {
    #    if [ -s $file ]
    #    then
    #        sed -i "\$a$com" $file
    sed -i '$ d' $2
    echo "$1" >> $2;
    echo "}" >> $2;
}

#Function to print the usage of the program, in case of failure from the user.
print_usage() {
    echo "Usage:  ./bdsh [OPTION] ... [COMMAND] [REQUEST]";
    echo "OPTION:";
    echo "-h            display usage";
    echo "-f FILE       json database file";
    echo "-j            json formated output for select command";
}

# Checking if the file passed as parameter is correct
error_on_file() {
    # Check if the file exists, otherwise, create it
    file=$@
    if [ ! -f file ]
    then
        touch $file;
    fi
    # Check if the file is at json format
    shopt -s nocasematch
    ext="${file:${#file} - 5}"
    if [[ "${ext}" != ".json" ]]
    then
        echoerr "You have to specify a json file";
        exit 1;
    fi
}

printLineSelect() {
    # Print column
    if [ "$3" == 0 ]; then
        echo -n "$2"
        for((i=0;i<=$((${1} - ${#2} - 1));i++)); do
            echo -n " "
        done
        echo -e "|"
        for((i=0;i<=$((${1} - 1));i++)); do
            echo -n "-"
        done
    fi
    # Print line
    if [ "$3" == 1 ]; then
        echo -n "$2"
        for((i=0;i<=$((${1} - ${#2} - 1));i++)); do
            echo -n " "
        done
        echo -e "|"
    fi
}

#########################
#  PROGRAM BEGINS HERE  #
#########################

#If there's no argument, we print the usage and exit the program
if [ -z "$1" ]
then
    print_usage;
    exit 1;
fi

# If the first argument is "-h"
if [ "$1" == "-h" ]
then
    print_usage;
    exit 0;
    # If the first argument is "-f"
elif [ "$1" == "-f" ]
then
    error_on_file $2;
    file=$2;
elif [ "$1" == "-j" ]
then
    echo "";
    # Do something here
fi

# Get the arguments after a query keyword
let tbl;
let it=0;
let is_found=0;
for i in "$@"
do
    if [ "$i" == "create" ] || [ "$i" == "describe" ] || [ "$i" == "select" ] || [ "$i" == "insert" ]
    then
        let is_found=1;
    fi
    if [ $is_found -eq 1 ]
    then
        tbl[it]=$i;
        let it=it+1;
    fi
done

# Choose the right option to take
if [ ${tbl[0]} == "create" ]                # CREATE FUNCTION
then
    if [ ${tbl[1]} == "database" ]
    then
        if [ -s $file ]
        then
            echoerr "Can't create a new database on a non-empty file";
            exit 1;
        else
            echo "{" >> $file;
            echo "}" >> $file;
        fi
    elif [ ${tbl[1]} == "table" ]
    then
        if grep -Fq "desc_${tbl[2]}" $file
        then
            echo "Table already exists";
            exit 1;
        fi
        header=$(head -n 2 $file);
        new_head="${header//[$'\t\r\n ']}";
        sed -i '$ d' $file;
        if [[ "$new_head" != '{}' ]]
        then
            sed -i '$ d' $file;
            echo "]," >> $file;
        fi
        echo "\"desc_${tbl[2]}\": [" >> $file;
        fields=$(echo ${tbl[3]} | tr "," "\n") >> $file;
        for f in $fields
        do
            echo "\"$f\"," >> $file;
        done
        lastline=$(awk '/./{line=$0} END{print line}' $file);
        sed -i '$ d' $file;
        echo "${lastline::-1}" >> $file;
        echo "]" >> $file;
        echo "}" >> $file;
    fi
elif [ ${tbl[0]} == "insert" ]          # INSERT FUNCTION
then
    if [[ ! $(grep -F "desc_${tbl[1]}" $file) ]]
    then
        echoerr "Can't find the associated table.";
        exit 1;
    fi
    if [[ ! $(grep -F "data_${tbl[1]}" $file) ]]
    then
        header=$(head -n 2 $file);
        new_head="${header//[$'\t\r\n ']}";
        sed -i '$ d' $file;
        if [[ "$new_head" != '{}' ]]
        then
            sed -i '$ d' $file;
            echo "]," >> $file;
        fi
        new_line=$(grep -n "desc_${tbl[1]}" $file | tr ":" "\n" | sed 's/ //g');
        new_line=(${new_line[@]});
        test_var=(${new_line[1]});
        while [ $test_var != "]" ] && [ $test_var != "]," ]
        do
            let new_line=new_line+1;
            test_var=$(sed -n "${new_line}p" $file | sed 's/ //g' | sed 's/\r//g');
            arr_desc+=$test_var;
        done;
        arr_desc=$(echo ${arr_desc[@]} | sed 's/\"//g' | sed 's/\]//g' | tr "," "\n");
        echo -e "\"data_${tbl[1]}\": [\n{" >> $file;
        fields=$(echo ${tbl[2]} | tr "," "\n" | tr "=" "\n") >> $file;
        need_print=0;
        is_printed=0;
        for a in $arr_desc
        do
            for f in $fields
            do
                if [ $need_print -eq 1 ]
                then
                    echo "\"$a\": \"$f\"," >> $file
                    let need_print=2;
                fi
                if [ $a = $f ]
                then
                    let need_print=1;
                fi
            done
            if [ $need_print -eq 0 ]
            then
                echo "\"$a\": \"\"," >> $file
            fi
        done
        lastline=$(awk '/./{line=$0} END{print line}' $file);
        sed -i '$ d' $file;
        echo "${lastline::-1}" >> $file;
        echo "}" >> $file;
        echo "]" >> $file;
        echo "}" >> $file;
    else
        new_line=$(grep -n "desc_${tbl[1]}" $file | tr ":" "\n" | sed 's/ //g');
        new_line=(${new_line[@]});
        test_var=(${new_line[1]});
        while [ $test_var != "]" ] && [ $test_var != "]," ]
        do
            let new_line=new_line+1;
            test_var=$(sed -n "${new_line}p" $file | sed 's/ //g' | sed 's/\r//g');
            arr_desc+=$test_var;
        done;
        arr_desc=$(echo ${arr_desc[@]} | sed 's/\"//g' | sed 's/\]//g' | tr "," "\n");
        new_line=$(grep -n "data_${tbl[1]}" $file | tr ":" "\n" | sed 's/ //g');
        new_line=(${new_line[@]});
        test_var=(${new_line[1]});
        while [ $test_var != "]" ] && [ $test_var != "]," ]
        do
            let new_line=new_line+1;
            test_var=$(sed -n "${new_line}p" $file | sed 's/ //g' | sed 's/\r//g');
        done;
        first_line=$new_line;
        let lastline=$new_line-1;
        testing=$(sed -n "${lastline}p" $file | sed 's/ //g' | sed 's/\r//g');
        if [ $testing = "}" ]
        then
            sed -i '$ d' $file;
            sed -i "${lastline}i\}," $file
        fi
        sed -i.bak "${first_line}i\{" $file;
        fields=$(echo ${tbl[2]} | tr "," "\n" | tr "=" "\n") >> $file;
        need_print=0;
        is_printed=0;
        for a in $arr_desc
        do
            for f in $fields
            do
                if [ $need_print -eq 1 ]
               then
                    let new_line=new_line+1;
                    sed -i "${new_line}i\"$a\": \"$f\"," $file;
                    let need_print=2;
                fi
                if [ $a = $f ]
                then
                    let need_print=1;
                fi
            done
            if [ $need_print -eq 0 ]
            then
                let new_line=new_line+1;
                sed -i "${new_line}i\"$a\": \"\"," $file;
            fi
        done
        lastline=$(sed -n "${new_line}p" $file | sed 's/ //g' | sed 's/\r//g');
        sed -i "${new_line}i\\${lastline::-1}" $file
        let new_line=new_line+1;
        sed -i "${new_line} d" $file;
        echo "}" >> $file;
    fi
elif [ ${tbl[0]} == "describe" ]                # DESCRIBE FUNCTION
then
        new_line=$(grep -n "desc_${tbl[1]}" $file | tr ":" "\n" | sed 's/ //g');
        new_line=(${new_line[@]});
        test_var=(${new_line[1]});
        must_end=0;
        while [ $test_var != "]" ] && [ $test_var != "]," ]
        do
            let new_line=new_line+1;
            test_var=$(sed -n "${new_line}p" $file | sed 's/ //g' | sed 's/\t//g' | sed 's/\r//g');
            arr_desc+=$test_var;
        done;
        arr_desc=$(echo ${arr_desc[@]} | sed 's/\"//g' | sed 's/\]//g' | tr "," "\n");
        echo "$arr_desc";
elif [ ${tbl[0]} == "select" ]
then
    let arrayLine;
    j=0;
    IFS=',' read -r -a table <<< "${tbl[1]}"
    IFS=',' read -r -a arrayColumn <<< "${tbl[2]}"
    for((i=0;i<=$((${#arrayColumn[*]}-1));i++)); do
        while IFS= read -r line ; do
            if [[ "$line" == *"desc_"* || "$line" == *"data_"* ]]; then
                getCategory=$(echo "$line" | cut -d'"' -f2)
            fi
            if [[ "$line" == *${arrayColumn[$i]}* && "$getCategory" != *"desc_"* ]]; then
                arrayLine[j]=$(echo "$line" | cut -d'"' -f4)
                # echo "${arrayLine[$j]}"
                ((j++))
            fi
        done < "$file";
        arrayLength=( "${arrayLength[@]}" "$((${#arrayLine[@]} - 1))" )
    done
    maxLength=0
    for((i=0;i<=$((${#arrayColumn[*]}-1));i++)); do
        for((j=0;j<=$((${arrayLength[0]}));j++)); do
            if [ "${#arrayLine[$p]}" -gt $maxLength ]; then
                maxLength=$((${#arrayLine[$p]} + 2))
            fi
            ((p++))
        done
        longestCharColumn=( "${longestCharColumn[@]}" "$maxLength" )
        maxLength=0
    done
    # Columns
    for((i=0;i<=$((${#arrayColumn[*]}-1));i++)); do
        echo -n "${arrayColumn[$i]}"
        for((j=0;j<=$((${longestCharColumn[$i]} - ${#arrayColumn[$i]} - 1));j++)); do
            echo -n " "
        done
        if [ -n "${arrayColumn[$i + 1]}" ]; then
            echo -n "| "
        else
            echo ""
        fi
    done
    # Display the '-'
    for((i=0;i<=$((${#longestCharColumn[*]}-1));i++)); do
        for((j=0;j<$((${longestCharColumn[$i]} + 1));j++)); do
            echo -n "-"
        done
    done
    echo ""
    # Display the content
    for((i=0;i<=$((${#arrayLine[*]} - ${arrayLength[0]} - 2));i++)); do
        echo -n "${arrayLine[$i]}"
        for((j=0;j<$((${longestCharColumn[0]} - ${#arrayLine[$i]} - 1));j++)); do
            echo -n " "
        done
        echo -n " | "
        echo -n "${arrayLine[$i + ${arrayLength[0]} + 1]}"
        echo ""
    done
fi